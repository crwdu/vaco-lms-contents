사용자 인증 기능은 어떤 어플리케이션에서든 자주 사용되고 개발자라면 누구나 반드시 알고 있어야 할 기초 교양과 같은 항목입니다. 사용자 인증과 관련해서 자주 등장하는 용어인 쿠키, 세션, 토큰 이 3가지에 대해
알아보도록 하겠습니다.

## Why do we need cookie & session ?

쿠키와 세션에 대해 알아보기 전에 왜 필요한지에 대한 이야기 부터 해보겠습니다. HTTP 프로토콜에는 2가지 특징이 존재합니다.

1. 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊는다 (connectionless)
2. 클라이언트와 서버의 통신이 끝나면 상태를 유지하지 않는다 (stateless)

위 2가지 특성으로 인해 서버는 클라이언트와 연결이 끊어지게 되면 클라이언트의 이전 상태를 기억하지 못하게 되고, 클라이언트가 과거에 로그인을 성공하더라도 로그인 정보를 유지할 수가 없게 됩니다.

하지만 현실세계에서는 브라우저에 접속하고 있는 현재 유저를 인지하고 있어야 하는 경우가 더 많습니다. 쇼핑몰에서 로그인 한 후 옷을 장바구니에 보관했는데 매번 페이지를 이동할 때 마다 새롭게 인증을 해야한다면 사용률이 현저히 떨어지겠죠 ? 이런 특성을 보완하려면 **웹 통신간 정보가 유지** 되어야 하고, **정보를 유지하기 위해서 사용하는 저장소가 바로 쿠키와 세션**입니다.

## Session

### Cookie

쿠키란 클라이언트(브라우저)에 `key`와 `value`값이 들어있는(이름, 값) 작은 데이터 파일입니다.  브라우저에 개발자 도구를 이용하여 쿠키를 직접 확인할 수 있습니다.

![쿠키.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/08744d8c-2d17-4698-beac-e64d87f8112b/쿠키.png)

쿠키는 주로 서버에 의해 만들어 집니다. 서버가 HTTP 응답 헤더(header)의 `Set-Cookie` 에 내용을 넣어 전달하면, 브라우저는 이 내용을 자체적으로 브라우저에 저장합니다. 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 요청(request)시에 헤더(header)에 넣어서 자동으로 서버에 전송한다는 특징이 있습니다.

쿠키란 각 도메인에 따라 별개로 취급되고 사용됩니다. 현재 접속한 도메인에 대한 쿠키가 브라우저에 존재한다면, 브라우저는 서버로 요청을 보낼때마다 모든 요청에 해당 쿠키를 헤더(header)에 포함 시키도록 되어있습니다. 서버는 쿠키에 담긴 정보를 토대로 현재 접속한 사용자에 대한 정보를 읽을 수 있습니다.

개발자 도구 콘솔창에 아래 코드를 실행하여 현재 브라우저에 저장된 쿠키를 확인해보겠습니다.

```jsx
alert(document.cookie); // cookie1=value1; cookie2=value2;...
```

![                                      브라우저 URL, 개인의 컴퓨터 상황에 따라 위와 다른 결과창이 나타날 수 있습니다](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a77f7c1f-b851-465b-a99d-c0bb5f709b85/스크린샷_2022-05-06_오후_1.39.19.png)

                                      브라우저 URL, 개인의 컴퓨터 상황에 따라 위와 다른 결과창이 나타날 수 있습니다

`document.cookie` 는 `name=value` 쌍으로 구성되어있고, 각 쌍은 세미콜론(;)으로 구분합니다. 이때 쌍 하나는 하나의 독립된 쿠키를 나타냅니다. `document.cookie` 를 통해 직접 값을 추가할 수도 있습니다. `docuemnt.cookie` 에 값을 할당하면 ****브라우저는 이 값을 받아 다른 쿠키에 영향을 주지 않고 해당 쿠키를 갱신합니다. 아래 코드를 실행하면 기존의 쿠키가 유지된 채, 쿠키에 설정한 값이 추가된걸 확인할 수 있습니다.

```jsx
document.cookie = "vanilla=coding";
alert(document.cookie);
```

세션은 쿠키를 기반으로하고 있지만, 사용자 정보 파일을 클라이언트(브라우저)에 저장하는 쿠키와 달리 세션은 **서버 측에서 관리**합니다. 유저가 로그인에 성공하게 되면, 서버는 유저 정보를 바탕으로 DB에 유저를 생성하게 됩니다. 이 유저 정보가 저장된 세션 ID를 클라이언트의 쿠키로 저장하게 됩니다. 매 request 요청 시 쿠키에 있는 세션ID를 통해 서버에서는 세션DB를 조회해서 유저의 정보를 가져와야합니다. 여기서 단순히 쿠키는 세션ID를 전달해주는 매개체일 뿐입니다.

이처럼 사용자가 우리 어플리케이션에 로그인하게 되면, 우리는 로그인한 사용자에 대한 정보를 받게 됩니다. 그리고 우리는 쿠키로 들어온 세션ID를 이용하여 데이터베이스나 서버 메모리 상에 특정 사용자에 관한 내용을 관리할 수 있습니다. 접속한 사용자에 대한 정보를 기반으로 생성되는 **추상적인 과정과 개념을 세션**이라고 합니다.

세션은 클라이언트의 상태를 추적함에 있어 DB에 의존하고 있고, 이는 매 request마다 DB를 조회해야 한다는 말입니다. 또 로그인한 유저가 여러명이라면 추적을 하기 위해선 모든 세션 ID를 세션 DB에 저장해야 합니다. 즉 유저가 증가할수록 서버에 필요한 리소스가 더 많아지게 됩니다. 이런 단점을 극복할 수 있는게 바로 JWT 입니다.

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2b1d590-69e0-4081-bb72-12f800b9d91b/1.png

### Flow Summary

1. 브라우저에 접속한 사용자가 사용자 인증 정보를 서버로 보냅니다. 예) 이메일 + 비밀번호
2. 서버는 해당 사용자가 존재하는지 확인한 후, 세션 정보를 생성하여 데이터베이스나 서버 메모리에 저장합니다.
3. 서버는 생성한 세션 정보의 ID값을 쿠키에 포함하여 브라우저로 전달합니다. (일반적으로 세션 ID만을 저장하지만, 상황에 따라 저장하는 정보가 다를 수 있습니다.)
4. 쿠키를 전달받은 브라우저는 앞으로 같은 도메인에 접속하여 요청을 보낼 경우, Header에 쿠키를 포함하게 됩니다.
5. 인증 권한이 필요한 다른 요청을 서버로 보냅니다. (쿠키는 자동으로 Header에 포함됩니다.)
6. 서버는 쿠키에 저장된 세션 ID를 이용하여 사용자에 대한 인증 정보를 검증합니다.
7. 검증이 통과될 경우, 요청에 대한 정상적인 처리를 진행하고 응답을 보냅니다.
8. 검증이 실패할 겨우, 요청에 대한 오류 처리를 진행하고 응답을 보냅니다.

### Pros

- 클라이언트에 노출되지 않고 서버에서 사용자 인증을 관리하기 때문에, Cross Site Scripting (XSS) 공격으로부터 안전합니다.

### Cons

- 서버에서 관리해야 할 내용이 생기는 것이므로, 서비스의 스케일이 커질수록 관리가 어려워집니다.
- Stateless하지 않습니다.
- 쿠키는 브라우저를 위해 만들어진 개념이기 때문에 브라우저가 아닌 환경에서 쿠키는 제약이 생기게 되므로 모바일 기기에 대한 지원이 어렵습니다.
- 서버와 다른 도메인의 클라이언트를 지원한다면 CORS 문제에 대한 해결책을 마련해야 합니다.
- Cross-Site Request Forgery (XSRF or CSRF) 공격에 취약합니다.

## JWT

### What is JWT?

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/08ed913c-baa8-4ec9-b1ce-7573af3b7d1b/2.png

JWT란, JSON Web Token의 줄임말로서 JSON 자료를 Encoding한 형태의 토큰을 의미합니다. **Header, Payload, Signature 세 가지 파트**로 이루어져 있으며 각 부분은 `.`을 이용하여 구분됩니다.

- 헤더(Header): 토큰 종류와 해시 알고리즘 정보가 들어 있습니다.
- 페이로드(Payload): 토큰의 내용물이 인코딩된 부분입니다.
- 시그니처(Signature): 일련의 문자열로, 시그니처를 통해 토큰이 변조되었는지 여부를 확인할 수 있습니다.

 
중요한 점은 Encryption(암호화)된 것이 아니라, Encoding된 토큰이라는 것입니다. 누구나 어렵지 않게 Decode할 수 있기 때문에 중요한 정보는 보관하지 않는 것이 좋습니다.

로그인 요청 시 올바른 정보를 기입하였다면 서버에서는 JWT를 로그인 정보를 이용하여 생성해줍니다. 클라이언트는 매 요청마다 헤더에 JWT를 실어 보내 인증을 확인하고 서버에서는 JWT를 확인하는 과정만 거친 후 정보를 보내주면 됩니다. 세션과 같은 방식처럼 서버에서 별도로 세션 ID를 저장해두거나, 세션 DB를 가질 필요도 없습니다. 유저인증을 하는데 있어 서버의 부담이 훨씬 줄어들게 됩니다. 

### Flow Summary

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e27d52b4-61f5-405b-a8a3-4a0d1a3de925/3.png

1. 클라이언트에서 서버로 사용자 정보와 함께 로그인 요청을 보냅니다.
2. 서버에서는 사용자 정보를 검증하고, 토큰을 발급합니다.
3. 클라이언트에서 토큰을 보관하고 사용자 인증이 필요한 요청을 보낼때 토큰을 함께 보냅니다.
    - 브라우저에서는 일반적으로 Local Storage를 가장 흔하게 사용합니다만, 보안적인 이슈가 있기도 합니다.
    - 일반적으로 서버로 토큰을 보낼때는 Request Header 내에 추가해서 보내며, Bearer Scheme을 사용합니다.
4. 서버에서는 토큰을 이용하여 사용자를 검증하고 요청에 대한 처리를 진행합니다.

### Pros

- 서버측의 작업이 Stateless합니다.
- 클라이언트가 토큰을 관리하게 되므로, 서버의 스케일링이 더욱 쉽습니다.
- JWT를 이용한 인증 방식이기 때문에 Cross Domain 이슈와 관계없이 검증을 할 수 있습니다.
- 모바일 기기에 대한 지원이 더욱 쉽습니다.
- Cross-Site Request Forgery (XSRF or CSRF) 공격으로부터 안전합니다.
    - 보통 CSRF에 대한 처리가 XSS에 대한 보안 처리보다 어렵습니다.

### Cons

- 토큰을 도난당할 경우, 막을 수 없습니다. 그래서 일반적으로 토큰 유효 기간을 아주 짧게 설정하고 자주 갱신해주도록 구현합니다.
- Cross Site Scripting (XSS)에 대한 위험이 있습니다. 하지만 React, Vue, Angular 등의 라이브러리는 이에 대한 보안 기능이 있습니다.

## Extra

[Starting with Authentication (A tutorial with Node.js and MongoDB)](https://medium.com/createdd-notes/starting-with-authentication-a-tutorial-with-node-js-and-mongodb-25d524ca0359)

[인코딩과 암호화 용어정리](https://eine.tistory.com/entry/%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%95%94%ED%98%B8%ED%99%94-%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC)